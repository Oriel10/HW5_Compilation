%{
    #include <iostream> //TODO: remove
    #include "compiler_impl.h"
    #include "error_output.hpp"
    using namespace std;
    extern void closeScope();

    extern stack<SymbolTable> tables_stack;
    extern stack<int> offsets_stack;
    extern size_t loop_counter;
    extern char* yytext;

    extern int yylineno;
    int yylex();
    void yyerror(char const*);
%}




%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token AUTO
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token ID
%token NUM
%token STRING

%token RBRACE
%token LBRACE
%token LPAREN
%token RPAREN

%right ASSIGN
%left OR
%left AND
%left RELOP_EQ /*new*/
%left RELOP_SIZE /*new*/
%left BINOP_PLUSMINUS /*new*/
%left BINOP_MULDIV /*new*/
%nonassoc CAST_PREC
%right NOT

%right IF
%right ELSE 



%%

Program :
        {startCompiler();} Funcs               {endCompiler();                 }
;

Funcs :
        /*epsilon*/                            {$$ = new Funcs();              }
    |   FuncDecl Funcs                         {$$ = new Funcs();              }
; 

FuncDecl :
        RetType ID LPAREN Formals RPAREN LBRACE
        {$$ = new FuncDecl(dynamic_cast<RetType*>($1), $2, dynamic_cast<Formals*>($4));} 
        Statements RBRACE                      {closeScope();                   }
;

RetType :
        Type                                   {$$ = new RetType(dynamic_cast<Type*>($1));}
    |   VOID                                   {$$ = new RetType($1);              }
;

Formals :
        /*epsilon*/                            {$$ = new Formals();             }        
    |   FormalsList                            {$$ = new Formals(dynamic_cast<FormalsList*>($1));}

FormalsList :
        FormalDecl                             {$$ = new FormalsList(dynamic_cast<FormalDecl*>($1));       }
    |   FormalDecl COMMA FormalsList           {$$ = new FormalsList(dynamic_cast<FormalDecl*>($1), dynamic_cast<FormalsList*>($3));    }
;

FormalDecl :
        Type ID                                {$$ = new FormalDecl(dynamic_cast<Type*>($1), $2);    }
;

Statements :
        Statement                              {$$ = new Statements();             }
    |   Statements Statement                   {$$ = new Statements();             }
;

Statement :
        LBRACE M Statements RBRACE             {$$ = new Statement();
                                                closeScope();                   }
    |   Type ID SC                             {$$ = new Statement(dynamic_cast<Type*>($1), $2);}
    |   Type ID ASSIGN Exp SC                  {$$ = new Statement(dynamic_cast<Type*>($1), $2, dynamic_cast<Exp*>($4));}
    |   AUTO ID ASSIGN Exp SC                  {$$ = new Statement($1, $2, dynamic_cast<Exp*>($4));}
    |   ID ASSIGN Exp SC                       {$$ = new Statement($1, dynamic_cast<Exp*>($3));}
    |   Call SC                                {$$ = new Statement(dynamic_cast<Call*>($1));           }
    |   RETURN SC                              {$$ = new Statement($1);         }
    |   RETURN Exp SC                          {$$ = new Statement(dynamic_cast<Exp*>($2));}
    |   IF LPAREN Exp RPAREN M 
        Statement %prec IF                     {$$ = new Statement($1, dynamic_cast<Exp*>($3), dynamic_cast<Statement*>($6));
                                                closeScope();                   }
    |   IF LPAREN Exp RPAREN M 
        Statement ELSE M2 Statement            {$$ = new Statement($1, dynamic_cast<Exp*>($3), $7);
                                                closeScope();}
    |   WHILE LPAREN Exp RPAREN 
        {openScope(); loop_counter++;}
        Statement                              {$$ = new Statement($1, dynamic_cast<Exp*>($3), dynamic_cast<Statement*>($6));
                                                closeScope(); loop_counter--;   }
    |   BREAK SC                               {$$ = new Statement($1);         }
    |   CONTINUE SC                            {$$ = new Statement($1);         }                                 
;

M :
        /*epsilon*/                            {openScope();                   };
;

M2 :
        /*epsilon*/                            {closeScope();                   
                                                openScope();                     }
;


Call :
        ID LPAREN ExpList RPAREN               {$$ = new Call($1, dynamic_cast<ExpList*>($3));}
    |   ID LPAREN RPAREN                       {$$ = new Call($1);                   }
;

ExpList :
        Exp                                    {$$ = new ExpList(dynamic_cast<Exp*>($1));}
    |   Exp COMMA ExpList                      {$$ = new ExpList(dynamic_cast<Exp*>($1), dynamic_cast<ExpList*>($3));}
;

Type :
        INT                                    {$$ = new Type($1);              }
    |   BYTE                                   {$$ = new Type($1);              }
    |   BOOL                                   {$$ = new Type($1);              }
;

Exp :
        LPAREN Exp RPAREN                      {$$ = new Exp(dynamic_cast<Exp*>($2));}
    |   Exp BINOP_MULDIV Exp                   {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    |   Exp BINOP_PLUSMINUS Exp                {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    |   ID                                     {$$ = new Exp(($1));                 }
    |   Call                                   {$$ = new Exp(dynamic_cast<Call*>($1));}
    |   NUM                                    {$$ = new Exp($1);                   }
    |   NUM B                                  {$$ = new Exp($1, $2);               }
    |   STRING                                 {$$ = new Exp($1);                   }
    |   TRUE                                   {$$ = new Exp($1);                   }
    |   FALSE                                  {$$ = new Exp($1);                   }
    |   NOT Exp                                {$$ = new Exp($1, dynamic_cast<Exp*>($2));}
    |   Exp AND Exp                            {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    |   Exp OR Exp                             {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    |   Exp RELOP_EQ Exp                       {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    |   Exp RELOP_SIZE Exp                     {$$ = new Exp(dynamic_cast<Exp*>($1), $2, dynamic_cast<Exp*>($3));}
    |   LPAREN Type RPAREN
         Exp %prec CAST_PREC                   {$$ = new Exp(dynamic_cast<Type*>($2), dynamic_cast<Exp*>($4));}
;

%%

int main()
{
    return yyparse();
}

void yyerror(char const* s){
    if (yychar == YYUNDEF){
        output::errorLex(yylineno);
    }
    else{
        output::errorSyn(yylineno);
    }
}